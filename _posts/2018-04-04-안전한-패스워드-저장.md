원본: [안전한 패스워드 저장](http://d2.naver.com/helloworld/318732)

참고: [고수준에서 암호학 이해하기](https://gist.github.com/aJchemist/f2d08f328f0458be8ee8)

원본 내용을 읽으면서 정리한 글입니다.

# 안전한 패스워드 저장

"보안 시스템은 가장 약한 연결 고리만큼만 강하다."

## 1. 해시 함수의 개념

### 1-1. 단방향 해시함수

입력 값의 일부만 바뀌어도 다이제스트가 완전히 달라지는 효과를 아발란체(Avalanche) 효과라고 한다.

해시 함수를 이용해 원본 메시지를 변환하여 만든 암호화 메시지를 다이제스트(digest)라고 한다.

### 1-2. 단방향 해시함수의 문제점

#### 1-2-1. 인식 가능성(recognizability)

동일한 메시지가 언제나 동일한 다이제스트를 갖는다면, 비교하여 알아낼 수 있다.

이러한 다이제스트 목록을 레인보우 테이블(rainbow table)이라 하고, 이러한 공격 방식을 레인보우 공격(rainbow attack)이라고 한다.

#### 1-2-2. 속도(speed)

해시 함수의 빠른 처리 속도로 인해 공격자는 매우 빠른 속도로 레인보우 공격을 할 수 있다.

### 1-3. 단방향 해시 함수 보완하기

#### 1-3-1. 솔팅(salting)

솔트(salt)는 단방향 해시 함수에서 다이제스트를 만들 때 추가하는 바이트 단위의 임의의 문자열이다.

원본 메시지에 문자열을 추가하여 다이제스트를 생성하는 것을 솔팅(salting)이라고 한다.

![솔팅](http://d2.naver.com/content/images/2015/06/helloworld-318732-1.png)

사용자마다 다른 솔트를 사용하고, 이를 데이터베이스에 저장하여 사용할 수 있다. 솔트의 길이는 32바이트 이상이어야 한다.

#### 1-3-2. 키 스트레칭(key stretching)

생성한 다이제스트를 입력 값으로 이용해 다이제스트를 생성하는 작업을 반복하는 것을 키 스트레칭이라고 한다. 패스워드를 동일한 횟수만큼 해시해야만 비교할 수 있다.

일반적으로 1초에 50억 개 이상의 다이제스트를 비교할 수 있지만, 키 스트레칭을 적용하면 1초에 5번 정도만 비교할 수 있게 만들 수 있다.

![솔팅과 키 스트레칭](http://d2.naver.com/content/images/2015/06/helloworld-318732-2.png)

## 2. 조정가능한 키 유도 함수

솔팅과 키 스트레칭을 반복하며, 입력 값을 추가하여 보안을 강화하고, 보안 강도를 선택할 수 있는 함수를 조정가능한 키 유도 함수(Adaptive Key Derivation Functions)라고 한다.

### 2-1. PBKDF2

가장 많이 사용되고 있다. 키 스트레칭 횟수를 선택할 수 있다. 가볍고, 구현하기 쉽다.

```
DIGEST = PBKDF2(PRF, Password, Salt, c, DLen)
```

- PRF: 난수(예: HMAC)
- Password: 패스워드
- Salt: 암호학 솔트
- c: 원하는 iteration 반복 수
- DLen: 원하는 다이제스트 길이

### 2-2. bcrypt

가장 강력한 해시 메커니즘 중 하나이다. "work factor"라는 인자는 다이제스트를 생성하는 데 얼마만큼의 처리 과정을 수행할지 결정한다.

입력값으로 72 바이트 문자를 사용해야 하는 제약이 있다.

```java
// Sample code for jBCrypt is a Java
// gensalt is work factor and the default is 10
String hashed = BCrypt.hashpw(password, BCrypt.gensalt(11));

// Check that an unencrypted password matches one that has
// previously been hashed
if (BCrypt.checkpw(candidate, hashed))  
    System.out.println("It matches");
else  
    System.out.println("It does not match");
```

### 2-3. scrypt

다이제스트를 생성할 때 메모리 오버헤드를 갖도록 설계되었다. PBKDF2보다 안전하다고 평가된다.

```
DIGEST = scrypt(Password, Salt, N, r, p, DLen)
```

- Password: 패스워드
- Salt: 암호학 솔트
- N: CPU 비용
- r: 메모리 비용
- p: 병렬화(parallelization)
- DLen: 원하는 다이제스트 길이

## 3. 마치며

MD5, SHA-1, SHA-256, SHA-512 등의 해시 함수는 메시지 인증과 무결성 체크를 위한 것이다. 비밀번호 인증을 위해 사용하면 인식 가능성과 빠른 처리 속도에 기인하는 취약점이 존재한다.

ISO-27001의 보안 규정을 준수하고, 서드파티의 라이브러리에 의존하지 않으려면 PBKDF2-HMAC-SHA-256/SHA-512를 사용하면 된다.

매우 강력한 다이제스트를 생성하려면 bcrypt를 사용하는 것이 좋다.

시스템이 매우 민감한 정보를 다루고, 많은 비용을 투자할 수 있다면 scrypt를 사용하면 된다.

패스워드 보안을 위해 더 쉽게 취할 수 있는 조치는 사용자가 최대한 긴 패스워드를 사용하도록 권장하는 것이다.